# Recruiting Assessment â€“ Atropos Health, Engineering Manager Role

## Demonstration (Video Walk Through)



https://github.com/user-attachments/assets/1dac191a-93cf-4b20-8dbf-26b6c92576a9


## Run this locally

- Make sure you have Docker installed and running on your machine.
- Clone this repository to your local machine.
- Navigate to the project directory in your terminal.
- Build the containers, `docker-compose build`
- Run the tests, `docker-compose run --rm web pytest .`
- Start the application, `docker-compose up -d`
- The application should now be running at `http://localhost:8000` (You'll see a message at that URL)
- You can access the auto-generated API documentation at `http://localhost:8000/docs`; Deeper details in this README.

## Things to try

Here are a few things to try, as curl commands. You can run these as is or open them in Postman or insomnia.


### Fetch allowed task types and information about the arguments they accept (there is just one right now)
```bash
curl http://localhost:8000/task-types/
```

### Post a new task (Returns a 202 Accepted response and starts the task in the background)
```bash 
curl -X POST http://localhost:8000/tasks/ \
  -H "Content-Type: application/json" \
  -d '{
    "type": "data-processing",
    "data": {
      "file_url": "https://example.com/my-data.csv",
      "delimiter": ","
    }
  }'
```

### Check the status and results of the task you created
```bash
curl http://localhost:8000/tasks/79e2da44-5d32-4661-a957-f5b2ea482858
```

## Caveats and project notes

- The task is not actually doing anything. It just simulates a long-running task by sleeping for 10 seconds.
- The development and tests databases are not currently isolated -- though side effects generated by tests are not preserved.
- We make use of some typing, but don't currently run a linter - in the future we should add a linter to the CI/CD pipeline. We could also type more heavily.

## The Assignment (From Atropos Health Team)

### Instructions
Build an API to manage long running tasks
Implement operations that can at a minimum:

- Create tasks
- Check  task status
- Retrieve task results

Assume tasks may take a significant amount of time to complete (e.g., data processing tasks, report generation, video processing).  


### Guidelines

You're free to choose any language/platform/stack, just be prepared to talk about them.

Assume that this will be production code that will need to be supported by a separate infrastructure team.

Provide some information about how to deploy the service locally for our team to be able to review

### [OPTIONAL] - Extra points for using:

- A containerization technology like Docker
- Testing framework
- Some minimal front-end
- Integration with a cloud provider's services that you think can help

### Presentation

Once you've created an API, please submit your artifacts via the submission link.  We'll reach out to you to schedule a the next interview to go over your submission. Be prepared to talk about the technology you used and the choices you made. 

Please note: Reviewers may decide that your submission does meet our coding standards and end the interview process this stage.

### Questions
Please reach out to with any questions

---
## Implementation (Max)

This Task Management API allows the initiation of tasks via a RESTful JSON API. Tasks have a type, and the API is written to be flexible, allowing for the addition of new task types in the future, for example, data processing tasks, report generation, or video processing. 


### Task Creation 

To initiate a task, issue a request that looks like the example below. Allowed values for type and data can be determined by making a request to `/task-types`.

```http
POST /tasks
```
```json
{
  "type": "data-processing",
  "data": {
    "file_url": "https://example.com/my-data.csv",
    "delimiter": ","
  }
}
```

The expected response for all tasks will be `202 Accepted` header with a JSON body with some information about the initiated task,
```json
{
  "task_id": "123xyz",
  "status": "pending",
  "type": "data-processing",
  "links": {
    "status": "/tasks/123xyz/status",
    "result": "/tasks/123xyz/result"
  }
}
```

### Retrieving Available Task Types

To retrieve a list of possible tasks types, issue a GET request,
```http
GET /task-types
```

That endpoint will respond with a list of allowed task schemas. Those schemas use the spec at https://json-schema.org/specification. For example,
```json
[
  {
    "description": "Processes a CSV file from a public URL and generates a summary report.",
    "payload_schema": {
      "$schema": "https://json-schema.org/draft/2020-12/schema",
      "properties": {
        "delimiter": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": ",",
          "description": "Optional delimiter used in the CSV file.",
          "title": "Delimiter"
        },
        "file_url": {
          "description": "Publicly accessible URL pointing to the input CSV file.",
          "format": "uri",
          "maxLength": 2083,
          "minLength": 1,
          "title": "File Url",
          "type": "string"
        }
      },
      "required": ["file_url"],
      "title": "Data Processing Input Schema",
      "type": "object"
    },
    "type": "data-processing"
  }
]
```

### Retrieving Task Status and Results

```http
GET /tasks/123xyz/
```

The response could be different whether the status is pending, in-progress, succeeded or failed. One possible example response,
```json
{
  "download_url": null,
  "status": "in-progress",
  "task_id": "123xyz",
  "type": "data-processing"
}
```

Tasks may have side effects. (for example a generated report) and those side effects could be downloaded from a link when extant. In that case, a 200 response code and a json body with a `download_link` would be appropriate. If there are no side effects, `download_link` may not be present. In all cases the json body will also include a `status` key which will correspond to `succeeded` or `failed`. If the task has not finished `download_link` will be `null` and the status will be `pending` or `in-progress`.

